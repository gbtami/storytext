#!/usr/bin/env python

### Command-line version of PyUseCase
# Now the instrumentation is less necessary this can
# just be used to run programs directly

# Usage pyusecase [ -r <record_file> ] [ -p <playback_file> ] <program>
import os, imp, sys, logging
from optparse import OptionParser

install_root = os.path.dirname(os.path.dirname(os.path.normpath(os.path.abspath(sys.argv[0]))))
# Find our own "lib" directory
sys.path.insert(0, os.path.join(install_root, "lib"))
        
import usecase

try:
    # In Py 2.x, the builtins were in __builtin__
    BUILTINS = sys.modules['__builtin__']
except KeyError: # pragma: no cover - not worried about Python 3 yet...
    # In Py 3.x, they're in builtins
    BUILTINS = sys.modules['builtins']


def run_python_file(args):
    """Run a python file as if it were the main program on the command line.
    
    `args` is the argument array to present as sys.argv, including the first
    element representing the file being executed.

    Lifted straight from coverage.py by Ned Batchelder
    
    """
    filename = args[0]
    # Create a module to serve as __main__
    old_main_mod = sys.modules['__main__']
    main_mod = imp.new_module('__main__')
    sys.modules['__main__'] = main_mod
    main_mod.__file__ = filename
    main_mod.__builtins__ = BUILTINS

    # Set sys.argv and the first path element properly.
    old_argv = sys.argv
    old_path0 = sys.path[0]
    sys.argv = args
    sys.path[0] = os.path.dirname(filename)

    try:
        source = open(filename, 'rU').read()
        exec compile(source, filename, "exec") in main_mod.__dict__
    finally:
        # Restore the old __main__
        sys.modules['__main__'] = old_main_mod
        
        # Restore the old argv and path
        sys.argv = old_argv
        sys.path[0] = old_path0


if __name__ == "__main__":
    usage = "usage: %prog [options] <program> <program_args> ..."
    parser = OptionParser(usage, version="%prog " + usecase.version)
    parser.disable_interspersed_args() # don't try to parse the application's args
    parser.add_option("-r", "--record", 
                      help="record script to FILE", metavar="FILE")
    parser.add_option("-p", "--replay", 
                      help="replay script from FILE", metavar="FILE")
    parser.add_option("-i", "--interface", metavar="INTERFACE",
                      help="type of interface used by application, should be 'console' or 'gtk' ('gtk' is default)", 
                      default="gtk")
    parser.add_option("-d", "--delay", metavar="SECONDS", 
                      help="amount of time to wait between each action when replaying")
    parser.add_option("-l", "--loglevel", default="INFO", 
                      help="produce logging at level LEVEL, should be 'info', 'debug' or 'off'", metavar="LEVEL")
    parser.add_option("-m", "--mapfiles", default=os.path.join(os.getenv("USECASE_HOME"), "ui_map.conf"),
                      help="Use the UI map file(s) at FILE1,...", metavar="FILE1,...")
    parser.add_option("-t", "--test", action="store_true", 
                      help="Used for internal testing: instruments also the interface for entering widget names")
    parser.add_option("-x", "--disable_usecase_names", action="store_true", 
                      help="Disable the entering of usecase names when unrecognised actions are recorded")


    options, args = parser.parse_args()
    if options.record:
        os.environ["USECASE_RECORD_SCRIPT"] = options.record
    if options.replay:
        os.environ["USECASE_REPLAY_SCRIPT"] = options.replay
    if options.delay:
        os.environ["USECASE_REPLAY_DELAY"] = options.delay
    if options.loglevel != "off":
        level = eval("logging." + options.loglevel.upper())
        logging.basicConfig(level=level, stream=sys.stdout, format="%(message)s")

    if options.interface == "gtk":
        import gtkusecase
        logEnabled = options.loglevel != "off"
        mapFiles = options.mapfiles.split(",")
        usecase.scriptEngine = gtkusecase.ScriptEngine(enableShortcuts=True, 
                                                       uiMapFiles=mapFiles,  
                                                       universalLogging=logEnabled)
    else:
        usecase.scriptEngine = usecase.ScriptEngine(enableShortcuts=True)

    run_python_file(args)
    if options.interface == "gtk" and not options.disable_usecase_names:
        usecase.scriptEngine.replaceAutoRecordingForUseCase(options.test)
