
""" Small GTK GUI to allow the user to enter domain names for user actions.
    Tkinter users still need GTK for TextTest to work... """

import gtk
from ndict import seqdict

class DomainNameGUI:
    signalDescs = {
        "row-activated" : "double-clicked row",
        "changed.selection" : "clicked on row",
        "delete-event": "closed",
        "notify::position": "dragged separator", 
        "toggled.true": "checked",
        "toggled.false": "unchecked",
        "button-press-event": "right-clicked row",
        "current-name-changed": "filename changed"
        }
    columnSignalDescs = {
        "toggled.true": "checked box in column",
        "toggled.false": "unchecked box in column",
        "edited": "edited cell in column",
        "clicked": "clicked column header"
        }
    title = "Enter Usecase names for auto-recorded actions"
    def __init__(self, autoGenerated, commands, scriptEngine, parent=None):
        self.dialog = gtk.Dialog(self.title, parent, flags=gtk.DIALOG_MODAL)
        self.dialog.set_name("Name Entry Window")
        self.allEntries = seqdict()
        self.dialog.set_default_response(gtk.RESPONSE_ACCEPT)
        contents = self.createTable(autoGenerated, scriptEngine)
        self.dialog.vbox.pack_start(contents, expand=True, fill=True)
        preview = self.createPreview(commands)
        self.dialog.vbox.pack_start(gtk.HSeparator())
        self.dialog.vbox.pack_start(preview, expand=True, fill=True)
        yesButton = self.dialog.add_button(gtk.STOCK_OK, gtk.RESPONSE_ACCEPT)
        scriptEngine.monitorSignal("finish name entry editing", "response", self.dialog, gtk.RESPONSE_ACCEPT, autoGenerated=True)
        self.dialog.show_all()
        
    def createMarkupLabel(self, markup):
        label = gtk.Label()
        label.set_markup(markup)
        return label

    def activateEntry(self, *args):
        self.dialog.response(gtk.RESPONSE_ACCEPT)

    def getActionDescription(self, signalName, widgetType):
        desc = self.signalDescs.get(signalName)
        if desc:
            return desc
        if signalName == "activate":
            if "Entry" in widgetType:
                return "pressed Enter"
            else:
                return "selected"
        elif signalName == "changed":
            if "Entry" in widgetType:
                return "edited text"
            else:
                return "selected item"

        parts = signalName.split(".")
        if len(parts) == 1:
            return signalName.replace("-", " ")

        if parts[0] == "response":
            return parts[1]

        columnName = parts[1]
        remaining = parts[0]
        if remaining == "toggled":
            remaining = ".".join([ remaining, parts[-1] ])
        return self.columnSignalDescs.get(remaining, remaining) + " '" + columnName + "'"
        
    def splitAutoCommand(self, command):
        for cmd in self.allEntries.keys():
            if command.startswith(cmd):
                arg = command.replace(cmd, "")
                return cmd, arg
        return None, None

    def updatePreview(self, entry, data):
        buffer, lineNo, arg = data
        text = entry.get_text()
        toUse = "?"
        if text:
            toUse = text + arg 
        start = buffer.get_iter_at_line(lineNo)
        end = buffer.get_iter_at_line(lineNo + 1)
        buffer.delete(start, end)
        buffer.insert(start, toUse + "\n")

    def createPreview(self, commands):
        frame = gtk.Frame("Current Usecase Preview")
        view = gtk.TextView()
        view.set_editable(False)
        view.set_cursor_visible(False)
        view.set_wrap_mode(gtk.WRAP_WORD)
        buffer = view.get_buffer()
        for ix, command in enumerate(commands):
            autoCmdName, autoArg = self.splitAutoCommand(command)
            if autoCmdName:
                buffer.insert(buffer.get_end_iter(), "?\n")
                entry = self.allEntries.get(autoCmdName)
                entry.connect("changed", self.updatePreview, (buffer, ix, autoArg))
            else:                
                buffer.insert(buffer.get_end_iter(), command + "\n")
        frame.add(view)
        return frame

    def createTable(self, autoGenerated, scriptEngine):
        table = gtk.Table(rows=len(autoGenerated) + 1, columns=4)
        table.set_col_spacings(20)
        headers = [ "Widget Type", "Identified By", "Action Performed", "Usecase Name" ]
        for col, header in enumerate(headers):
            table.attach(self.createMarkupLabel("<b><u>" + header + "</u></b>"), 
                         col, col + 1, 0, 1, xoptions=gtk.FILL)
        for rowIndex, (command, widgetType, widgetDesc, signalName) in enumerate(autoGenerated):
            table.attach(gtk.Label(widgetType), 0, 1, rowIndex + 1, rowIndex + 2, xoptions=gtk.FILL)
            actionDesc = self.getActionDescription(signalName, widgetType)
            table.attach(gtk.Label(widgetDesc), 1, 2, rowIndex + 1, rowIndex + 2, xoptions=gtk.FILL)
            table.attach(gtk.Label(actionDesc), 2, 3, rowIndex + 1, rowIndex + 2, xoptions=gtk.FILL)
            entry = gtk.Entry()
            scriptName = "enter usecase name for signal '" + signalName + "' on " + widgetType + " '" + widgetDesc + "' ="
            scriptEngine.monitorSignal(scriptName, "changed", entry, autoGenerated=True)
            entry.connect("activate", self.activateEntry)
            scriptEngine.monitorSignal("finish name entry editing by pressing <enter>", "activate", entry, autoGenerated=True)
            self.allEntries[command] = entry
            table.attach(entry, 3, 4, rowIndex + 1, rowIndex + 2)
        frame = gtk.Frame("Previously unseen actions: provide names for the interesting ones")
        frame.add(table)
        return frame

    def collectNames(self):
        names = [ entry.get_text() for entry in self.allEntries.values() ]
        self.dialog.destroy()
        return names
